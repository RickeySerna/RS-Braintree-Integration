<head>
</head>

<body>
    <!-- Creating two input dates for the search parameters and a button to generate the graph. -->
<input type="date" id="start-date">
<input type="date" id="end-date">
    <button id="graph-generator">Search</button>
    <div class="graphStyle">
        <canvas id="transaction-chart"></canvas>
    </div>
    <!-- Creating divs for the checkbox options; one for transaction type, one for transaction status. -->
    <div id="transaction-types">
        <!-- Checkbox options for transaction types will added here dynamically. -->
    </div>
    <div id="transaction-statuses">
        <!-- Checkbox options for transaction statuses will be added here dynamically. -->
    </div>
     <div id="transaction-card-types">
        <!-- Checkbox options for transaction card types will be added here dynamically. -->
    </div>
    <!-- Space for info about the transactions pulled will be generated here. -->
    <div id="search-results-info">

    </div>
    <script>
        // Declare the chart variable globally so that it's accessible when we run fetchTransactionData a second time.
        var transactionChart;

        // Declaring the variables for the information that will be displayed in search-results-info and filled in generateGraph().
        let searchAmountTotal = 0;
        let processorDeclinedTotal = 0;
        let gatewayRejectedTotal = 0;
        var numberOfTransactions = 0;
        var transactionTypeCounts = {};

        // The plugin code for the transaction info box. This will be used to overlay the box right on top of the chart.
        // I'm declaring it globally to make sure it's in scope when it's thrown into the graph later.

        // Setting the AJAX call inside of a function so that we can readily call it again when the button is clicked.
        function generateGraph(startDate, endDate) {
            $.ajax({
                // Passing the parameters over to the server for use there.
                // Everything before ? is the path to the route.
                // Everything after ? is the query string. So if the dates are both 2024-01-01 it's being passed as: /transactionDataForAnalytics?startDate=2024-01-01&endDate=2024-01-01
                // Then we can access startDate and endDate in the server.
                url: '/transactionDataForAnalytics?startDate=' + startDate + '&endDate=' + endDate,
                type: 'GET',
                dataType: 'json',
                success: function(response) {
                    // The arrays are in reverse order chronologically, so we're reversing them now.
                    var createdAt = response.createdAt.reverse();
                    var amounts = response.amounts.reverse();
                    var ids = response.ids.reverse();
                    var statuses = response.statuses.reverse();
                    var types = response.types.reverse();
                    var cardTypes = response.cardTypes.reverse();

                    console.log("Date array: ", createdAt);
                    console.log("Amount array: ", amounts);
                    console.log("ID array: ", ids);
                    console.log("Status array: ", statuses);
                    console.log("Type array: ", types);
                    console.log("Card type array: ", cardTypes);

                    // This function fills the globally defined variables with information from the search results we pulled.
                    // This will be used to fill in the textbox on the chart summarizing the transactions returned.
                    // Updating this to take arrays as parameters. This way the information generated is updated when the user filters data out.
                    function fillSearchResultsInfo(filteredDates, filteredAmounts, filteredIDs, filteredStatuses, filteredTypes, filteredCardTypes) {
                        // Making sure the chart exists.
                        console.log(transactionChart);

                        // Resetting all of the variables so that they don't keep being added to if the user searches again.
                        // Resetting the amount to 0.
                        searchAmountTotal = 0;
                        // Resetting the declined amount to 0.
                        processorDeclinedTotal = 0;
                        // Resetting the rejected amount to 0.
                        gatewayRejectedTotal = 0;
                        // Resetting the transaction count to 0.
                        numberOfTransactions = 0;
                        // Emptying the map.
                        transactionTypeCounts = {};

                        // This will only count transactions that are not filtered out now.
                        for (let i = 0; i < filteredDates.length; i++) {
                            if (filteredDates[i] != null) {
                                numberOfTransactions += 1;
                            }
                        }
                        console.log("Total transactions found: " + numberOfTransactions);

                        // This for loop fills searchAmountTotal, processorDeclinedTotal, and atewayRejectedTotal with the amounts of transactions with each status.
                        // We create a few cases that fit each status and each individual var has the amount added if the index in filteredStatuses matches that status.
                        for (let i = 0; i < filteredDates.length; i++) {
                            let thisAmount = parseFloat(filteredAmounts[i]);
                            switch (filteredStatuses[i]) {
                                // Both of these statuses are succesful so either one can add to searchAmountTotal.
                                case "Settled":
                                case "Authorized":
                                    searchAmountTotal += thisAmount;
                                    break;
                                case "Processor Declined":
                                    processorDeclinedTotal += thisAmount;
                                    break;
                                case "Gateway Rejected":
                                    gatewayRejectedTotal += thisAmount;
                                    break;
                            }
                        }
                        // When there are many transactions, long floating points are generated, like this: 677.8399999999999
                        // This will round the number to the nearest hundredths place. Also wrapped in parseFloat() since toFixed() returns a string.
                        searchAmountTotal = parseFloat(searchAmountTotal.toFixed(2));
                        processorDeclinedTotal = parseFloat(processorDeclinedTotal.toFixed(2));
                        gatewayRejectedTotal = parseFloat(gatewayRejectedTotal.toFixed(2));
                        console.log("Total successfully transacted: " + searchAmountTotal)
                        console.log("Total amount Processor Declined: " + processorDeclinedTotal);
                        console.log("Total amount Gateway Rejected: " + gatewayRejectedTotal);

                        for (let i = 0; i < types.length; i++) {
                            // Including this check now so that there doesn't end up being a category for null if the user filters anything out.
                            if (filteredTypes[i] !== null) {
                                if (!transactionTypeCounts[filteredTypes[i]]) {
                                    transactionTypeCounts[filteredTypes[i]] = 0;
                                }
                                transactionTypeCounts[filteredTypes[i]]++;
                            }
                        }
                        console.log("Count of transaction types: ", transactionTypeCounts);

                        // Grabbing the dates from the date inputs to throw into the text box.
                        var startDate = document.getElementById('start-date').value;
                        var endDate = document.getElementById('end-date').value;

                        // Formatting the dates so that they're more readable to humans with moment.js. Same thing we do on the server.
                        var formattedStartDate = moment(startDate).format('MMMM Do, YYYY');
                        var formattedEndDate = moment(endDate).format('MMMM Do, YYYY');

                        // This is where we generate the actual message that will appear on top of the chart.
                        var infoText = 'Transaction Summary for ' + formattedStartDate + ' to ' + formattedEndDate + '\n';
                        infoText += '   ' + 'Total transactions found: ' + numberOfTransactions + '\n';
                        infoText += '   ' + 'Total amount successfully transacted: $' + searchAmountTotal + '\n';
                        infoText += '   ' + 'Total amount Processor Declined: $' + processorDeclinedTotal + '\n';
                        infoText += '   ' + 'Total amount Gateway Rejected: $' + gatewayRejectedTotal + '\n';
                        infoText += '   ' + 'Total transactions of each type:\n';
                        for (var type in transactionTypeCounts) {
                            infoText += '   ' + '   ' + type + ': ' + transactionTypeCounts[type] + '\n';
                        }

                        // Ensure that transactionChart.options.elements exists. If it doesn't, we create it as an empty object.
                        if (!transactionChart.options.elements) {
                            transactionChart.options.elements = {};
                        }

                        // transactionChart.options.elements defined.
                        transactionChart.options.elements.center = {
                            text: infoText,
                            fontSize: 15,
                            fontStyle: 'normal',
                            fontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif"
                        };
                    }

                    // afterDraw is a hook that executes after the chart is drawn. In our case, it generates the text we defined in fillSearchResultsInfo().
                    // Has to be declared outside of the chart as a plugin like this.

                    var afterDrawPlugin = {
                        id: 'afterDrawPlugin',
                        afterDraw: function(chart, args, options) {
                            var ctx = chart.ctx;
                            var centerConfig = chart.options.elements.center;
                            var globalConfig = Chart.defaults.font;

                            var fontStyle = centerConfig.fontStyle || globalConfig.style;
                            var fontFamily = centerConfig.fontFamily || globalConfig.family;

                            // Calculate the font size as a percentage of the chart height
                            var fontSize = chart.height * 0.025; // 5% of the chart height

                            ctx.font = Chart.helpers.toFontString({
                                size: fontSize,
                                style: fontStyle,
                                family: fontFamily,
                            });

                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'top';
                            var lines = centerConfig.text.split('\n'); // Split the text into lines

                            // Define a line height based on the font size
                            var lineHeight = fontSize + 2.5;

                            var topPadding = 10;
                            var widthPadding = 10;

                            var maxWidth = 0;
                            lines.forEach(function(line) {
                                var lineWidth = ctx.measureText(line).width;
                                if (lineWidth > maxWidth) {
                                    maxWidth = lineWidth;
                                }
                            });

                            // Calculate the box width as a percentage of the chart width
                            var boxWidth = maxWidth + 2 * widthPadding;
                            // Calculate the box height based on the number of lines and line height
                            var boxHeight = lines.length * lineHeight;

                            // Ensure the boxWidth does not exceed the chart area width
                            if (boxWidth > chart.chartArea.width) {
                                boxWidth = chart.chartArea.width;
                            }

                            var x = chart.chartArea.right - boxWidth; // Calculate x based on the boxWidth
                            var y = chart.chartArea.top + topPadding; // Start at the top of the chart

                            ctx.fillStyle = 'rgba(255, 207, 135, 0.1)'; // Set the color of the box
                            ctx.fillRect(x - 5, y - 5, boxWidth, boxHeight); // Draw the box
                            ctx.fillStyle = 'black'; // Set the color of the text

                            lines.forEach(function(line, i) {
                                ctx.fillText(line, x, y + (i * lineHeight)); // Draw each line separately
                            });
                        }
                    };

                    // Then it's registered into the Chart.js object. It can actually be used in any chart we create now, but that's not so relevant here.
                    Chart.register(afterDrawPlugin);

                    // These lines are creating arrays from the types and statuses arrays, but only with the unique values.
                    // A Set is an object that only allows unique values. So new Set(response.xxx) is creating Sets from those arrays and those sets inherently only contain the unique values in the array.
                    // The ... is the spread operator. It sort of "breaks down" an iterable that's passed into it's individual parts.
                    // So it's passed a set containing unique types/statuses and it pulls out those unique types/statuses.
                    // Then this is all wrapped in [] so it's creating an array from those types/statuses that ... pulled out of the Set.
                    var transactionTypes = [...new Set(types)];
                    var transactionStatuses = [...new Set(statuses)];
                    var transactionCardTypes = [...new Set(cardTypes)];

                    // Checking that the arrays are accurate.
                    console.log("Transaction types array: ", transactionTypes);
                    console.log("Transaction statuses array: ", transactionStatuses);

                    // Add checkboxes for each transaction type
                    transactionTypes.forEach(function(type) {
                        $('#transaction-types').append('<input type="checkbox" checked value="' + type + '">' + type + '<br>');
                    });

                    // Add checkboxes for each transaction status
                    transactionStatuses.forEach(function(status) {
                        $('#transaction-statuses').append('<input type="checkbox" checked value="' + status + '">' + status + '<br>');
                    });

                    // Add checkboxes for each transaction status
                    transactionCardTypes.forEach(function(status) {
                        $('#transaction-card-types').append('<input type="checkbox" checked value="' + status + '">' + status + '<br>');
                    });

                    // Function to draw the chart
                    function drawChart() {
                        // Check if the chart exists, then destroy it if it does.
                        if (transactionChart) {
                            transactionChart.destroy();
                        }

                        var selectedTypes = $('#transaction-types input:checked').map(function() {
                            return this.value;
                        }).get();

                        var selectedStatuses = $('#transaction-statuses input:checked').map(function() {
                            return this.value;
                        }).get();

                        var selectedCardTypes = $('#transaction-card-types input:checked').map(function() {
                            return this.value;
                        }).get();

                        // Now that we're just setting the x axis as the original, full createdAt array, the filteredIndex array is not necessary.
                        // Now instead, filteredDates gets added to in a similar manner as filteredAmounts.
                        // If the transaction in createdAt passes the filter, it gets added to array in the correct index.
                        // Otherwise, null is thrown in to keep the index accurate.
                        // This isn't actually being used anywhere rn, but maybe in the future?
                        // Update: it became useful! Passing this into fillSearchResultsInfo along with the other arrays I'm building the same way.
                        // Also, just realized I had these using the original response.xxx arrays instead of the reversed ones. Fixed that.
                        var filteredDates = createdAt.map(function(date, i) {
                            if (selectedTypes.includes(response.types[i]) && selectedStatuses.includes(response.statuses[i]) && selectedCardTypes.includes(response.cardTypes[i])) {
                                return date;
                            }
                            else {
                                return null;
                            }
                        });

                        // Since we're keeping the x axis consistent now, changed how the transactions are filtered.
                        // Now, in order to keep this filteredAmounts array at the same length as the original array, we throw null values in the place of the original filtered out transaction.
                        // If the txn passes the filters, it gets added to the array. If it does not, null gets thrown in.
                        // This is important bc Chart.js will ignore a null value. So doing it like this means that only the transactions that pass the filter will show up in the graph.
                        var filteredAmounts = amounts.map(function(amount, i) {
                            if (selectedTypes.includes(response.types[i]) && selectedStatuses.includes(response.statuses[i]) && selectedCardTypes.includes(response.cardTypes[i])) {
                                return amount;
                            }
                            else {
                                return null;
                            }
                        });

                        // Filtered array for the transaction IDs.
                        var filteredIDs = ids.map(function(id, i) {
                            if (selectedTypes.includes(response.types[i]) && selectedStatuses.includes(response.statuses[i]) && selectedCardTypes.includes(response.cardTypes[i])) {
                                return id;
                            }
                            else {
                                return null;
                            }
                        });

                        // Filtered array for the statuses.
                        var filteredStatuses = statuses.map(function(status, i) {
                            if (selectedTypes.includes(response.types[i]) && selectedStatuses.includes(response.statuses[i]) && selectedCardTypes.includes(response.cardTypes[i])) {
                                return status;
                            }
                            else {
                                return null;
                            }
                        });

                        // Filtered array for the types.
                        var filteredTypes = types.map(function(type, i) {
                            if (selectedTypes.includes(response.types[i]) && selectedStatuses.includes(response.statuses[i]) && selectedCardTypes.includes(response.cardTypes[i])) {
                                return type;
                            }
                            else {
                                return null;
                            }
                        });

                        // Filtered array for the card types.
                        var filteredCardTypes = cardTypes.map(function(cardType, i) {
                            if (selectedTypes.includes(response.types[i]) && selectedStatuses.includes(response.statuses[i]) && selectedCardTypes.includes(response.cardTypes[i])) {
                                return cardType;
                            }
                            else {
                                return null;
                            }
                        });

                        console.log("filteredDates: ", filteredDates);
                        console.log("filteredAmounts: ", filteredAmounts);
                        console.log("filteredIDs: ", filteredIDs);
                        console.log("filteredStatuses: ", filteredStatuses);
                        console.log("filteredTypes: ", filteredTypes);
                        console.log("filteredCardTypes: ", filteredCardTypes);

                        var ctx = document.getElementById('transaction-chart');
                        transactionChart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: createdAt,
                                datasets: [{
                                    label: 'Transactions',
                                    data: filteredAmounts,
                                    backgroundColor: 'purple',
                                    borderColor: '#FF8E51',
                                    borderWidth: 1,
                                    spanGaps: true
                                }]
                            },
                            options: {
                                scales: {
                                    y: {
                                        beginAtZero: true
                                    }
                                },
                                // It's working! tooltip is nested inside of plugins. Now it shows a proper label.
                                plugins: {
                                    tooltip: {
                                        callbacks: {
                                            // Filtered index is not necessary anymore, so just grabbing the original index returned here.
                                            title: function(context) {
                                                var index = context[0].dataIndex;
                                                var transactionId = ids[index];
                                                return "#" + (index + 1) + ' - Transaction ID: ' + transactionId;
                                            },
                                            label: function(context) {
                                                var index = context.dataIndex;
                                                var amount = amounts[index];
                                                var status = statuses[index];
                                                var cardType = cardTypes[index];
                                                var type = types[index];
                                                var date = createdAt[index];

                                                return [
                                                    'Amount: $' + amount,
                                                    'Status: ' + status,
                                                    'Card Type: ' + cardType,
                                                    'Type: ' + type,
                                                    'Date: ' + date
                                                ];
                                            }
                                        }
                                    }
                                }
                            }
                        });

                        // Generate the information from the search results. Has to be done after the chart already exists so we call it after drawChart().
                        // Moving this inside of drawChart() so that it's called every time a filter is clicked. The chart breaks otherwise.
                        // The filtered arrays are passed into here now so that the information in the textbox updates based on the filters. If a transaction is filtered out, it's not used in any of the counts now.
                        fillSearchResultsInfo(filteredDates, filteredAmounts, filteredIDs, filteredStatuses, filteredTypes, filteredCardTypes);

                        // Adding an onclick handler which triggers when a datapoint in the graph is clicked.
                        // It leads to the URL for that transaction in the BT Control Panel.
                        ctx.onclick = function(evt) {
                            // Once the user clicks somewhere on the chart, activePoints is filled with an array containing all of the datapoints in the graph.
                            var activePoints = transactionChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                            // If the user didn't click on a datapoint specifically, that activePoints array will be empty, hence less than 0 and so we don't do anything more.
                            if (activePoints.length > 0) {
                                console.log(activePoints);
                                // If they clicked on a datapoint, activePoints will be filled with data and so we do all of this.
                                // The 'nearest' parameter in getElementsAtEventForMode means that the function returns the datapoints nearest to where we clicked.
                                // If we had mulltipe datapoints at the same location, the activePoints array would fill with all of them.
                                // In this case, the graph only has one datapoint in any given location so activePoints always has a length of 1.

                                // So now we create a var containing the object with that 1 datapoint in activePoints.
                                var firstPoint = activePoints[0];
                                // That object contains an index which is it's position in the dataset that the graph was created from.
                                // So if it was the 4 datapoint, the index here will be 3.
                                // Updating this to use the filtered index we used above. Now, it'll pull the transaction from the index that was filterd with the checkboxes.
                                var index = firstPoint.index;
                                // Now we take that index and index the ids array we got back from the AJAX call.
                                // The correct transaction ID will be pulled here since the graph was created from that ids array.
                                var transactionId = ids[index];
                                // Merchant ID is now pulled from the .env file.
                                var merchantId = "{{merchantId}}";

                                // Constructing the URL and opening it in a new tab.
                                var url = 'https://sandbox.braintreegateway.com/merchants/' + merchantId + '/transactions/' + transactionId;
                                window.open(url, '_blank');
                            }
                        };
                    }

                    // Draw the chart initially
                    drawChart();

                    // Redraw the chart whenever a checkbox is checked or unchecked
                    $('#transaction-types input, #transaction-statuses input, #transaction-card-types input').change(drawChart);
                },
                error: function(jqXHR, status, error) {
                    console.log('AJAX call failed.');
                    console.log('Status: ' + status);
                    console.log('Error: ' + error);
                }
            });
        }

        // Event listener for the graph generator button. No graph is created until this is clicked.
        $('#graph-generator').click(function() {
            // Also doing this here so that the chart is destroyed immediately once the button is clicked.
            if (transactionChart) {
                transactionChart.destroy();
            }

            // Define the search parameters from the date inputs above.
            var startDate = $('#start-date').val();
            var endDate = $('#end-date').val();

            console.log(startDate);
            console.log(endDate);

            // Adding a check to make sure the start date is before or on the same date as the end date.
            // If it is, we move forward with emptying the checkboxes and running generateGraph() again.
            // Without making sure of this, it surprisingly doesn't throw an error, but no data will be returned.
            if (startDate <= endDate) {
                // If multiple searches were ran without reloading the page, the checkbox options would persist after each search.
                // Now clearing the checkbox divs when the search button is clicked.
                $('#transaction-types').empty();
                $('#transaction-statuses').empty();
                $('#transaction-card-types').empty();

                // Run the function to create the graph with these dates as the search parameters.
                generateGraph(startDate, endDate);
            }
            // If it's not, we give the user an error and end things then and there with return.
            else {
                alert("The starting search date must be on or before the ending search date.");
                return;
            }
        });
    </script>
</body>