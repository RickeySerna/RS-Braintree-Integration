<head>
</head>

<body>
    <!-- Creating two input dates for the search parameters and a button to generate the graph. -->
<input type="date" id="start-date">
<input type="date" id="end-date">
    <button id="graph-generator">Search</button>

    <!-- Div holding the line chart. -->
    <div class="graphStyle">
        <h1>Transactions Per Transaction</h1>
        <canvas id="transaction-line-chart"></canvas>
    </div>

    <!-- Creating divs for the checkbox options for the line chart. -->
    <div id="transaction-types-line-chart">
        <p>Payment Methods:</p>
        <!-- Checkbox options for transaction types on the line chart will added here dynamically. -->
    </div>
    <div id="transaction-statuses-line-chart">
        <p>Statuses:</p>
        <!-- Checkbox options for transaction statuses on the line chart will be added here dynamically. -->
    </div>
     <div id="transaction-card-types-line-chart">
        <p>Card Types:</p>
        <!-- Checkbox options for transaction card types on the line chart will be added here dynamically. -->
    </div>

    <!-- Div holding the bar chart. -->
    <div class="graphStyle">
        <h1>Transactions Per Day</h1>
        <canvas id="transaction-bar-chart"></canvas>
    </div>

    <!-- Creating divs for the checkbox options for the bar chart. -->
    <div id="transaction-types-bar-chart">
        <p>Payment Methods:</p>
        <!-- Checkbox options for transaction types on the bar chart will added here dynamically. -->
    </div>
    <div id="transaction-statuses-bar-chart">
        <p>Statuses:</p>
        <!-- Checkbox options for transaction statuses on the bar chart will be added here dynamically. -->
    </div>
     <div id="transaction-card-types-bar-chart">
        <p>Card Types:</p>
        <!-- Checkbox options for transaction card types on the bar chart will be added here dynamically. -->
    </div>

    <script>
        // Declare the chart variable globally so that it's accessible when we run fetchTransactionData a second time.
        var transactionChart;
        // Declaring another variable for the bar chart.
        var transactionBarChart;

        // Setting the AJAX call inside of a function so that we can readily call it again when the button is clicked.
        function generateGraph(startDate, endDate) {
            $.ajax({
                // Passing the parameters over to the server for use there.
                // Everything before ? is the path to the route.
                // Everything after ? is the query string. So if the dates are both 2024-01-01 it's being passed as: /transactionDataForAnalytics?startDate=2024-01-01&endDate=2024-01-01
                // Then we can access startDate and endDate in the server.
                url: '/transactionDataForAnalytics?startDate=' + startDate + '&endDate=' + endDate,
                type: 'GET',
                dataType: 'json',
                success: function(response) {
                    // The arrays are in reverse order chronologically, so we're reversing them now.
                    var createdAt = response.createdAt.reverse();
                    var amounts = response.amounts.reverse();
                    var ids = response.ids.reverse();
                    var statuses = response.statuses.reverse();
                    var types = response.types.reverse();
                    var cardTypes = response.cardTypes.reverse();

                    console.log("Date array: ", createdAt);
                    console.log("Amount array: ", amounts);
                    console.log("ID array: ", ids);
                    console.log("Status array: ", statuses);
                    console.log("Type array: ", types);
                    console.log("Card type array: ", cardTypes);

                    // This function generates the filtered arrays that we were previously generating manually one by one.
                    // It returns an array built from the "array" it was passed.
                    // The array is filled with the property values which pass the filters.
                    // Now, we can just define this logic once, then use it for all 12 times we create these array.
                    // Also takes selected... arrays since those are different for each graphs.
                    function filterArrays(array, selectedTypes, selectedStatuses, selectedCardTypes) {
                        return array.map(function(item, i) {
                            if (selectedTypes.includes(response.types[i]) && selectedStatuses.includes(response.statuses[i]) && selectedCardTypes.includes(response.cardTypes[i])) {
                                return item;
                            }
                            else {
                                return null;
                            }
                        });
                    }

                    // This function fills the globally defined variables with information from the search results we pulled.
                    // This will be used to fill in the textbox on the chart summarizing the transactions returned.
                    // Updating this to take arrays as parameters. This way the information generated is updated when the user filters data out.
                    function fillSearchResultsInfo(filteredDates, filteredAmounts, filteredIDs, filteredStatuses, filteredTypes, filteredCardTypes) {
                        // Making sure the chart exists.
                        console.log(transactionChart);

                        // These are not defined globally anymore, they're just defined here each time the function is called. Functions the same.
                        // Resetting the amount to 0.
                        searchAmountTotal = 0;
                        // Resetting the declined amount to 0.
                        processorDeclinedTotal = 0;
                        // Resetting the rejected amount to 0.
                        gatewayRejectedTotal = 0;
                        // Resetting the transaction count to 0.
                        numberOfTransactions = 0;
                        // Emptying the map.
                        transactionTypeCounts = {};

                        // This will only count transactions that are not filtered out now.
                        for (let i = 0; i < filteredDates.length; i++) {
                            if (filteredDates[i] != null) {
                                numberOfTransactions += 1;
                            }
                        }
                        console.log("Total transactions found: " + numberOfTransactions);

                        // This for loop fills searchAmountTotal, processorDeclinedTotal, and atewayRejectedTotal with the amounts of transactions with each status.
                        // We create a few cases that fit each status and each individual var has the amount added if the index in filteredStatuses matches that status.
                        for (let i = 0; i < filteredDates.length; i++) {
                            let thisAmount = parseFloat(filteredAmounts[i]);
                            switch (filteredStatuses[i]) {
                                // Both of these statuses are succesful so either one can add to searchAmountTotal.
                                case "Settled":
                                case "Authorized":
                                    searchAmountTotal += thisAmount;
                                    break;
                                case "Processor Declined":
                                    processorDeclinedTotal += thisAmount;
                                    break;
                                case "Gateway Rejected":
                                    gatewayRejectedTotal += thisAmount;
                                    break;
                            }
                        }
                        // When there are many transactions, long floating points are generated, like this: 677.8399999999999
                        // This will round the number to the nearest hundredths place. Also wrapped in parseFloat() since toFixed() returns a string.
                        searchAmountTotal = parseFloat(searchAmountTotal.toFixed(2));
                        processorDeclinedTotal = parseFloat(processorDeclinedTotal.toFixed(2));
                        gatewayRejectedTotal = parseFloat(gatewayRejectedTotal.toFixed(2));
                        console.log("Total successfully transacted: " + searchAmountTotal)
                        console.log("Total amount Processor Declined: " + processorDeclinedTotal);
                        console.log("Total amount Gateway Rejected: " + gatewayRejectedTotal);

                        for (let i = 0; i < types.length; i++) {
                            // Including this check now so that there doesn't end up being a category for null if the user filters anything out.
                            if (filteredTypes[i] !== null) {
                                if (!transactionTypeCounts[filteredTypes[i]]) {
                                    transactionTypeCounts[filteredTypes[i]] = 0;
                                }
                                transactionTypeCounts[filteredTypes[i]]++;
                            }
                        }
                        console.log("Count of transaction types: ", transactionTypeCounts);

                        // Grabbing the dates from the date inputs to throw into the text box.
                        var startDate = document.getElementById('start-date').value;
                        var endDate = document.getElementById('end-date').value;

                        // Formatting the dates so that they're more readable to humans with moment.js. Same thing we do on the server.
                        var formattedStartDate = moment(startDate).format('MMMM Do, YYYY');
                        var formattedEndDate = moment(endDate).format('MMMM Do, YYYY');

                        // This is where we generate the actual message that will appear on top of the chart.
                        var infoText = 'Transaction Summary for ' + formattedStartDate + ' to ' + formattedEndDate + '\n';
                        infoText += '   ' + 'Total transactions found: ' + numberOfTransactions + '\n';
                        infoText += '   ' + 'Total amount successfully transacted: $' + searchAmountTotal + '\n';
                        infoText += '   ' + 'Total amount Processor Declined: $' + processorDeclinedTotal + '\n';
                        infoText += '   ' + 'Total amount Gateway Rejected: $' + gatewayRejectedTotal + '\n';
                        infoText += '   ' + 'Total transactions of each type:\n';
                        for (var type in transactionTypeCounts) {
                            infoText += '   ' + '   ' + type + ': ' + transactionTypeCounts[type] + '\n';
                        }

                        // Ensure that transactionChart.options.elements exists. If it doesn't, we create it as an empty object.
                        if (!transactionChart.options.elements) {
                            transactionChart.options.elements = {};
                        }

                        // transactionChart.options.elements defined.
                        transactionChart.options.elements.center = {
                            text: infoText,
                            fontSize: 15,
                            fontStyle: 'normal',
                            fontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif"
                        };
                    }

                    // The afterDraw plugin is registered for all charts so we need to make a function which adds a center element, similar to the above function.
                    // The plugin throws an error if we don't do this.
                    function fillBarChartInfo(filteredDates, filteredAmounts, filteredIDs, filteredStatuses, filteredTypes, filteredCardTypes) {

                        // This is essentially doing the same thing as the other function for the line chart.

                        // Making sure the chart exists.
                        console.log(transactionBarChart);

                        // Resetting the amount to 0.
                        searchAmountTotalBar = 0;
                        // Resetting the declined amount to 0.
                        processorDeclinedTotalBar = 0;
                        // Resetting the rejected amount to 0.
                        gatewayRejectedTotalBar = 0;
                        // Resetting the transaction count to 0.
                        numberOfTransactionsBar = 0;
                        // Emptying the map.
                        transactionTypeCountsBar = {};

                        // Counting the number of transactions.
                        for (let i = 0; i < filteredDates.length; i++) {
                            if (filteredDates[i] != null) {
                                numberOfTransactionsBar += 1;
                            }
                        }
                        console.log("Total transactions found: " + numberOfTransactions);

                        // This for loop fills searchAmountTotal, processorDeclinedTotal, and gatewayRejectedTotal with the amounts of transactions with each status.
                        // We create a few cases that fit each status and each individual var has the amount added if the index in filteredStatuses matches that status.
                        for (let i = 0; i < filteredDates.length; i++) {
                            let thisAmount = parseFloat(filteredAmounts[i]);
                            switch (filteredStatuses[i]) {
                                // Both of these statuses are succesful so either one can add to searchAmountTotal.
                                case "Settled":
                                case "Authorized":
                                    searchAmountTotalBar += thisAmount;
                                    break;
                                case "Processor Declined":
                                    processorDeclinedTotalBar += thisAmount;
                                    break;
                                case "Gateway Rejected":
                                    gatewayRejectedTotalBar += thisAmount;
                                    break;
                            }
                        }
                        // When there are many transactions, long floating points are generated, like this: 677.8399999999999
                        // This will round the number to the nearest hundredths place. Also wrapped in parseFloat() since toFixed() returns a string.
                        searchAmountTotalBar = parseFloat(searchAmountTotalBar.toFixed(2));
                        processorDeclinedTotalBar = parseFloat(processorDeclinedTotalBar.toFixed(2));
                        gatewayRejectedTotalBar = parseFloat(gatewayRejectedTotalBar.toFixed(2));
                        console.log("Total successfully transacted: " + searchAmountTotalBar)
                        console.log("Total amount Processor Declined: " + processorDeclinedTotalBar);
                        console.log("Total amount Gateway Rejected: " + gatewayRejectedTotalBar);

                        for (let i = 0; i < types.length; i++) {
                            // Including this check now so that there doesn't end up being a category for null if the user filters anything out.
                            if (filteredTypes[i] !== null) {
                                if (!transactionTypeCountsBar[filteredTypes[i]]) {
                                    transactionTypeCountsBar[filteredTypes[i]] = 0;
                                }
                                transactionTypeCountsBar[filteredTypes[i]]++;
                            }
                        }
                        console.log("Count of transaction types: ", transactionTypeCountsBar);

                        // Grabbing the dates from the date inputs to throw into the text box.
                        var startDate = document.getElementById('start-date').value;
                        var endDate = document.getElementById('end-date').value;

                        // Formatting the dates so that they're more readable to humans with moment.js. Same thing we do on the server.
                        var formattedStartDate = moment(startDate).format('MMMM Do, YYYY');
                        var formattedEndDate = moment(endDate).format('MMMM Do, YYYY');

                        // This is where we generate the actual message that will appear on top of the chart.
                        var infoText = 'Transaction Summary for ' + formattedStartDate + ' to ' + formattedEndDate + '\n';
                        infoText += '   ' + 'Total transactions found: ' + numberOfTransactionsBar + '\n';
                        infoText += '   ' + 'Total amount successfully transacted: $' + searchAmountTotalBar + '\n';
                        infoText += '   ' + 'Total amount Processor Declined: $' + processorDeclinedTotalBar + '\n';
                        infoText += '   ' + 'Total amount Gateway Rejected: $' + gatewayRejectedTotalBar + '\n';
                        infoText += '   ' + 'Total transactions of each type:\n';
                        for (var type in transactionTypeCountsBar) {
                            infoText += '   ' + '   ' + type + ': ' + transactionTypeCountsBar[type] + '\n';
                        }

                        if (!transactionBarChart.options.elements) {
                            transactionBarChart.options.elements = {};
                        }

                        transactionBarChart.options.elements.center = {
                            text: infoText,
                            fontSize: 15,
                            fontStyle: 'normal',
                            fontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif"
                        };
                    }

                    // afterDraw is a hook that executes after the chart is drawn. In our case, it generates the text we defined in fillSearchResultsInfo().
                    // Has to be declared outside of the chart as a plugin like this.

                    var afterDrawPlugin = {
                        id: 'afterDrawPlugin',
                        afterDraw: function(chart, args, options) {
                            var ctx = chart.ctx;
                            var centerConfig = chart.options.elements.center;
                            var globalConfig = Chart.defaults.font;

                            var fontStyle = centerConfig.fontStyle || globalConfig.style;
                            var fontFamily = centerConfig.fontFamily || globalConfig.family;

                            // Calculate the font size as a percentage of the chart height
                            var fontSize = chart.height * 0.025; // 5% of the chart height

                            ctx.font = Chart.helpers.toFontString({
                                size: fontSize,
                                style: fontStyle,
                                family: fontFamily,
                            });

                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'top';
                            var lines = centerConfig.text.split('\n'); // Split the text into lines

                            // Define a line height based on the font size
                            var lineHeight = fontSize + 2.5;

                            var topPadding = 10;
                            var widthPadding = 10;

                            var maxWidth = 0;
                            lines.forEach(function(line) {
                                var lineWidth = ctx.measureText(line).width;
                                if (lineWidth > maxWidth) {
                                    maxWidth = lineWidth;
                                }
                            });

                            // Calculate the box width as a percentage of the chart width
                            var boxWidth = maxWidth + 2 * widthPadding;
                            // Calculate the box height based on the number of lines and line height
                            var boxHeight = lines.length * lineHeight;

                            // Ensure the boxWidth does not exceed the chart area width
                            if (boxWidth > chart.chartArea.width) {
                                boxWidth = chart.chartArea.width;
                            }

                            var x = chart.chartArea.right - boxWidth; // Calculate x based on the boxWidth
                            var y = chart.chartArea.top + topPadding; // Start at the top of the chart

                            ctx.fillStyle = 'rgba(255, 207, 135, 0.1)'; // Set the color of the box
                            ctx.fillRect(x - 5, y - 5, boxWidth, boxHeight); // Draw the box
                            ctx.fillStyle = 'black'; // Set the color of the text

                            lines.forEach(function(line, i) {
                                ctx.fillText(line, x, y + (i * lineHeight)); // Draw each line separately
                            });
                        }
                    };

                    // Then it's registered into the Chart.js object. It can actually be used in any chart we create now, that why it only has to be registered once for both charts..
                    Chart.register(afterDrawPlugin);

                    // These lines are creating arrays from the types and statuses arrays, but only with the unique values.
                    // A Set is an object that only allows unique values. So new Set(response.xxx) is creating Sets from those arrays and those sets inherently only contain the unique values in the array.
                    // The ... is the spread operator. It sort of "breaks down" an iterable that's passed into it's individual parts.
                    // So it's passed a set containing unique types/statuses and it pulls out those unique types/statuses.
                    // Then this is all wrapped in [] so it's creating an array from those types/statuses that ... pulled out of the Set.
                    var transactionTypes = [...new Set(types)];
                    var transactionStatuses = [...new Set(statuses)];
                    var transactionCardTypes = [...new Set(cardTypes)];

                    // Checking that the arrays are accurate.
                    console.log("Transaction types array: ", transactionTypes);
                    console.log("Transaction statuses array: ", transactionStatuses);

                    // Add checkboxes for each transaction type
                    transactionTypes.forEach(function(type) {
                        $('#transaction-types-line-chart').append('<input type="checkbox" checked value="' + type + '">' + type + '<br>');
                        $('#transaction-types-bar-chart').append('<input type="checkbox" checked value="' + type + '">' + type + '<br>');
                    });

                    // Add checkboxes for each transaction status
                    transactionStatuses.forEach(function(status) {
                        $('#transaction-statuses-line-chart').append('<input type="checkbox" checked value="' + status + '">' + status + '<br>');
                        $('#transaction-statuses-bar-chart').append('<input type="checkbox" checked value="' + status + '">' + status + '<br>');
                    });

                    // Add checkboxes for each transaction status
                    transactionCardTypes.forEach(function(status) {
                        $('#transaction-card-types-line-chart').append('<input type="checkbox" checked value="' + status + '">' + status + '<br>');
                        $('#transaction-card-types-bar-chart').append('<input type="checkbox" checked value="' + status + '">' + status + '<br>');
                    });

                    // Function to draw the chart
                    function drawChart() {
                        // Check if the chart exists, then destroy it if it does.
                        if (transactionChart) {
                            transactionChart.destroy();
                        }

                        var selectedTypes = $('#transaction-types-line-chart input:checked').map(function() {
                            return this.value;
                        }).get();

                        var selectedStatuses = $('#transaction-statuses-line-chart input:checked').map(function() {
                            return this.value;
                        }).get();

                        var selectedCardTypes = $('#transaction-card-types-line-chart input:checked').map(function() {
                            return this.value;
                        }).get();

                        // Now that we're just setting the x axis as the original, full createdAt array, the filteredIndex array is not necessary.
                        // Now instead, filteredDates gets added to in a similar manner as filteredAmounts.
                        // If the transaction in createdAt passes the filter, it gets added to array in the correct index.
                        // Otherwise, null is thrown in to keep the index accurate.
                        // This isn't actually being used anywhere rn, but maybe in the future?
                        // Update: it became useful! Passing this into fillSearchResultsInfo along with the other arrays I'm building the same way.
                        // Also, just realized I had these using the original response.xxx arrays instead of the reversed ones. Fixed that.
                        // 2nd update: Just using the filterArrays() function to generate these arrays now.
                        var filteredDates = filterArrays(createdAt, selectedTypes, selectedStatuses, selectedCardTypes);

                        // Since we're keeping the x axis consistent now, changed how the transactions are filtered.
                        // Now, in order to keep this filteredAmounts array at the same length as the original array, we throw null values in the place of the original filtered out transaction.
                        // If the txn passes the filters, it gets added to the array. If it does not, null gets thrown in.
                        // This is important bc Chart.js will ignore a null value. So doing it like this means that only the transactions that pass the filter will show up in the graph.
                        var filteredAmounts = filterArrays(amounts, selectedTypes, selectedStatuses, selectedCardTypes);

                        // Filtered array for the transaction IDs.
                        var filteredIDs = filterArrays(ids, selectedTypes, selectedStatuses, selectedCardTypes);

                        // Filtered array for the statuses.
                        var filteredStatuses = filterArrays(statuses, selectedTypes, selectedStatuses, selectedCardTypes);

                        // Filtered array for the types.
                        var filteredTypes = filterArrays(types, selectedTypes, selectedStatuses, selectedCardTypes);

                        // Filtered array for the card types.
                        var filteredCardTypes = filterArrays(cardTypes, selectedTypes, selectedStatuses, selectedCardTypes);

                        console.log("filteredDates: ", filteredDates);
                        console.log("filteredAmounts: ", filteredAmounts);
                        console.log("filteredIDs: ", filteredIDs);
                        console.log("filteredStatuses: ", filteredStatuses);
                        console.log("filteredTypes: ", filteredTypes);
                        console.log("filteredCardTypes: ", filteredCardTypes);

                        var ctx = document.getElementById('transaction-line-chart');
                        transactionChart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: createdAt,
                                datasets: [{
                                    label: 'Transactions',
                                    data: filteredAmounts,
                                    backgroundColor: 'purple',
                                    borderColor: '#FF8E51',
                                    borderWidth: 1,
                                    spanGaps: true
                                }]
                            },
                            options: {
                                scales: {
                                    y: {
                                        beginAtZero: true
                                    }
                                },
                                // It's working! tooltip is nested inside of plugins. Now it shows a proper label.
                                plugins: {
                                    tooltip: {
                                        callbacks: {
                                            // Filtered index is not necessary anymore, so just grabbing the original index returned here.
                                            title: function(context) {
                                                var index = context[0].dataIndex;
                                                var transactionId = ids[index];
                                                return "#" + (index + 1) + ' - Transaction ID: ' + transactionId;
                                            },
                                            label: function(context) {
                                                var index = context.dataIndex;
                                                var amount = amounts[index];
                                                var status = statuses[index];
                                                var cardType = cardTypes[index];
                                                var type = types[index];
                                                var date = createdAt[index];

                                                return [
                                                    'Amount: $' + amount,
                                                    'Status: ' + status,
                                                    'Card Type: ' + cardType,
                                                    'Type: ' + type,
                                                    'Date: ' + date
                                                ];
                                            }
                                        }
                                    }
                                }
                            }
                        });

                        // Generate the information from the search results. Has to be done after the chart already exists so we call it after drawChart().
                        // Moving this inside of drawChart() so that it's called every time a filter is clicked. The chart breaks otherwise.
                        // The filtered arrays are passed into here now so that the information in the textbox updates based on the filters. If a transaction is filtered out, it's not used in any of the counts now.
                        fillSearchResultsInfo(filteredDates, filteredAmounts, filteredIDs, filteredStatuses, filteredTypes, filteredCardTypes);

                        // Adding an onclick handler which triggers when a datapoint in the graph is clicked.
                        // It leads to the URL for that transaction in the BT Control Panel.
                        ctx.onclick = function(evt) {
                            // Once the user clicks somewhere on the chart, activePoints is filled with an array containing all of the datapoints in the graph.
                            var activePoints = transactionChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                            // If the user didn't click on a datapoint specifically, that activePoints array will be empty, hence less than 0 and so we don't do anything more.
                            if (activePoints.length > 0) {
                                console.log(activePoints);
                                // If they clicked on a datapoint, activePoints will be filled with data and so we do all of this.
                                // The 'nearest' parameter in getElementsAtEventForMode means that the function returns the datapoints nearest to where we clicked.
                                // If we had mulltipe datapoints at the same location, the activePoints array would fill with all of them.
                                // In this case, the graph only has one datapoint in any given location so activePoints always has a length of 1.

                                // So now we create a var containing the object with that 1 datapoint in activePoints.
                                var firstPoint = activePoints[0];
                                // That object contains an index which is it's position in the dataset that the graph was created from.
                                // So if it was the 4 datapoint, the index here will be 3.
                                // Updating this to use the filtered index we used above. Now, it'll pull the transaction from the index that was filterd with the checkboxes.
                                var index = firstPoint.index;
                                // Now we take that index and index the ids array we got back from the AJAX call.
                                // The correct transaction ID will be pulled here since the graph was created from that ids array.
                                var transactionId = ids[index];
                                // Merchant ID is now pulled from the .env file.
                                var merchantId = "{{merchantId}}";

                                // Constructing the URL and opening it in a new tab.
                                var url = 'https://sandbox.braintreegateway.com/merchants/' + merchantId + '/transactions/' + transactionId;
                                window.open(url, '_blank');
                            }
                        };
                    }

                    // This function is generating the dates that will be the x axis on the bar chart.
                    // Doing this in a separate function in order to avoid generating this array over and over each time drawBarChart() is called.
                    // drawBarChart() will be called each time a filter is applied, but the x axis remains consistent anyway. So it would be a waste to do this insde of drawBarChart().
                    function generateDatesForBarChart(thisStartDate, thisEndDate) {
                        var dates = [];
                        var currentDate = moment(thisStartDate);

                        while (currentDate <= moment(thisEndDate)) {
                            dates.push(currentDate.format('YYYY-MM-DD'));
                            currentDate = currentDate.add(1, 'days');
                        }

                        return dates;
                    }

                    // This function is generating the actual data that will appear in the bar chart.
                    function generateDataForBarChart(dates, createdAt, amounts, statuses) {

                        // Create 3 new arrays of the same length as the dates array (to be pulled from generateDatesForBarChart).
                        // Immediately fill every space with 0 so that if a date doesn't have any transactions, it still displays 0.
                        // One array for successful txn amounts, one for declined amounts, one for rejected amounts.
                        let dataSuccessful = new Array(dates.length).fill(0);
                        let dataDeclined = new Array(dates.length).fill(0);
                        let dataRejected = new Array(dates.length).fill(0);

                        // Formatting all of the dates back into the YYYY-MM-DD format to match the format in the dates array.
                        let createdAtFormatted = createdAt.map(dateStr => {
                            return moment(dateStr, 'MMMM Do, YYYY - h:mm A').format('YYYY-MM-DD');
                        });

                        // Initializing an index variable outside of the for loop.
                        let currentDateIndex = 0;
                        // Iterating over the createdAtFormatted array we just created.
                        for (let i = 0; i < createdAtFormatted.length; i++) {

                            // This while loop advances the currentDateIndex which is used to iterate move across the dates array.
                            // The first condition checks if createdAtFormatted[i] is greater/later than dates[currentDateIndex].
                            // If that's the case, then we can move to the next spot in the dates array so we increment currentDateIndex by 1.
                            // The second index just makes sure currentDateIndex doesn't go past the length of dates to avoid out of bounds errors.
                            while (createdAtFormatted[i] > dates[currentDateIndex] && currentDateIndex < dates.length - 1) {
                                currentDateIndex++;
                            }

                            // Checkiing that the date we're currently on in createdAtFormatted and the date the currentDateIndex is on in dates are the same.
                            // If so, add the i index of amounts into to the currentDateIndex index in the data array we're building here.
                            // Basically, toss the amount of the transaction into the array if we're on equal dates in both arrays.
                            if (createdAtFormatted[i] === dates[currentDateIndex]) {
                                if (statuses[i] === "Settled" || statuses[i] === "Authorized" || statuses[i] === "Settling" || statuses[i] === "Submitted For Settlement") {
                                    dataSuccessful[currentDateIndex] += amounts[i];
                                }
                                else if (statuses[i] === "Processor Declined") {
                                    dataDeclined[currentDateIndex] += amounts[i];
                                }
                                else if (statuses[i] === "Gateway Rejected") {
                                    dataRejected[currentDateIndex] += amounts[i];
                                }
                            }
                        }

                        // Return all three arrays in one object .
                        return [dataSuccessful, dataDeclined, dataRejected];
                    }

                    function drawBarChart(dates) {

                        if (transactionBarChart) {
                            transactionBarChart.destroy();
                        }

                        // Creating the selected types arrays in the same way we do for the line chart.
                        // Have to do this separately for each one to allow the user to choose different filters for each graph.
                        var selectedTypesBarChart = $('#transaction-types-bar-chart input:checked').map(function() {
                            return this.value;
                        }).get();

                        var selectedStatusesBarChart = $('#transaction-statuses-bar-chart input:checked').map(function() {
                            return this.value;
                        }).get();

                        var selectedCardTypesBarChart = $('#transaction-card-types-bar-chart input:checked').map(function() {
                            return this.value;
                        }).get();

                        console.log("The bar chart types: ", selectedTypesBarChart);
                        console.log("The bar chart statuses: ", selectedStatusesBarChart);
                        console.log("The bar chart card types: ", selectedCardTypesBarChart);

                        // Similarly, creating the filtered arrays in the same way.
                        // Update: Creating these using the filterArrays() function now.
                        // Filtered array for the dates.
                        var filteredDatesBarChart = filterArrays(createdAt, selectedTypesBarChart, selectedStatusesBarChart, selectedCardTypesBarChart);

                        // Filtered array for the amounts.
                        var filteredAmountsBarChart = filterArrays(amounts, selectedTypesBarChart, selectedStatusesBarChart, selectedCardTypesBarChart);

                        // Filtered array for the transaction IDs.
                        var filteredIDsBarChart = filterArrays(ids, selectedTypesBarChart, selectedStatusesBarChart, selectedCardTypesBarChart);

                        // Filtered array for the statuses.
                        var filteredStatusesBarChart = filterArrays(statuses, selectedTypesBarChart, selectedStatusesBarChart, selectedCardTypesBarChart);

                        // Filtered array for the types.
                        var filteredTypesBarChart = filterArrays(types, selectedTypesBarChart, selectedStatusesBarChart, selectedCardTypesBarChart);

                        // Filtered array for the card types.
                        var filteredCardTypesBarChart = filterArrays(cardTypes, selectedTypesBarChart, selectedStatusesBarChart, selectedCardTypesBarChart);

                        // The amounts array is all strings so we convert them to numbers.
                        var fixedAmounts = filteredAmountsBarChart.map(Number);

                        console.log("Bar chart amounts after formatting: ", fixedAmounts);

                        // The data returned by the generateDataForBarChart function above.
                        var [dataSuccessful, dataDeclined, dataRejected] = generateDataForBarChart(dates, createdAt, fixedAmounts, filteredStatusesBarChart);

                        var ctx = document.getElementById("transaction-bar-chart");
                        transactionBarChart = new Chart(ctx, {
                            type: 'bar',
                            data: {
                                labels: dates,
                                datasets: [{
                                    label: "Successful Transactions",
                                    data: dataSuccessful,
                                    backgroundColor: "green",
                                    borderColor: '#FF8E51',
                                    borderWidth: 1,
                                    categoryPercentage: 0.8,
                                    barPercentage: 0.9
                                },
                                {
                                    label: "Processor Declined Transactions",
                                    data: dataDeclined,
                                    backgroundColor: "red",
                                    borderColor: '#FF8E51',
                                    borderWidth: 1,
                                    categoryPercentage: 0.8,
                                    barPercentage: 0.9
                                },
                                {
                                    label: "Gateway Rejected Transactions",
                                    data: dataRejected,
                                    backgroundColor: "blue",
                                    borderColor: '#FF8E51',
                                    borderWidth: 1,
                                    categoryPercentage: 0.8,
                                    barPercentage: 0.9
                                }]
                            },
                            options: {
                                scales: {
                                    y: {
                                        beginAtZero: true
                                    }
                                }
                            }
                        });

                        fillBarChartInfo(filteredDatesBarChart, filteredAmountsBarChart, filteredIDsBarChart, filteredStatusesBarChart, filteredTypesBarChart, filteredCardTypesBarChart);
                    }

                    // The parameters to be used to generate the dates array.
                    var thisStartDate = $('#start-date').val();
                    var thisEndDate = $('#end-date').val();

                    // Creating the dates array with our above function.
                    var dates = generateDatesForBarChart(thisStartDate, thisEndDate);

                    console.log("The date array geneated: ", dates)

                    // Draw the charts initially
                    drawChart();
                    drawBarChart(dates);

                    // Redraw the chart whenever a checkbox is checked or unchecked.
                    $('#transaction-types-line-chart input, #transaction-statuses-line-chart input, #transaction-card-types-line-chart input').change(drawChart);
                    $('#transaction-types-bar-chart input, #transaction-statuses-bar-chart input, #transaction-card-types-bar-chart input').change(function() {
                        drawBarChart(dates);
                    });
                },
                error: function(jqXHR, status, error) {
                    console.log('AJAX call failed.');
                    console.log('Status: ' + status);
                    console.log('Error: ' + error);
                }
            });
        }

        // Event listener for the graph generator button. No graph is created until this is clicked.
        $('#graph-generator').click(function() {
            // Also doing this here so that the chart is destroyed immediately once the button is clicked.
            if (transactionChart) {
                transactionChart.destroy();
            }

            if (transactionBarChart) {
                transactionBarChart.destroy();
            }

            // Define the search parameters from the date inputs above.
            var startDate = $('#start-date').val();
            var endDate = $('#end-date').val();

            console.log(startDate);
            console.log(endDate);

            // Adding a check to make sure the start date is before or on the same date as the end date.
            // If it is, we move forward with emptying the checkboxes and running generateGraph() again.
            // Without making sure of this, it surprisingly doesn't throw an error, but no data will be returned.
            if (startDate <= endDate) {
                // If multiple searches were ran without reloading the page, the checkbox options would persist after each search.
                // Now clearing the checkbox divs for the line chart when the search button is clicked.
                $('#transaction-types-line-chart').empty();
                $('#transaction-statuses-line-chart').empty();
                $('#transaction-card-types-line-chart').empty();

                // Also clearing the checkbox divs for the bar chart
                $('#transaction-types-bar-chart').empty();
                $('#transaction-statuses-bar-chart').empty();
                $('#transaction-card-types-bar-chart').empty();

                // Run the function to create the graph with these dates as the search parameters.
                generateGraph(startDate, endDate);
            }
            // If it's not, we give the user an error and end things then and there with return.
            else {
                alert("The starting search date must be on or before the ending search date.");
                return;
            }
        });
    </script>
</body>