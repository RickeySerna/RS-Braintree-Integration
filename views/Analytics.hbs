<head>
</head>

<body>
    <!-- Creating two input dates for the search parameters and a button to generate the graph. -->
    <input type="date" id="start-date">
    <input type="date" id="end-date">
    <button id="graph-generator">Search</button>
    <div class="graphStyle">
        <canvas id="transaction-chart"></canvas>
    </div>
    <!-- Creating divs for the checkbox options; one for transaction type, one for transaction status. -->
    <div id="transaction-types">
        <!-- Checkbox options for transaction types will added here dynamically. -->
    </div>
    <div id="transaction-statuses">
        <!-- Checkbox options for transaction statuses will be added here dynamically. -->
    </div>
     <div id="transaction-card-types">
        <!-- Checkbox options for transaction card types will be added here dynamically. -->
    </div>
    <script>
        // Declare the chart variable globally so that it's accessible when we run fetchTransactionData a second time.
        var transactionChart;

        // Setting the AJAX call inside of a function so that we can readily call it again when the button is clicked.
        function generateGraph(startDate, endDate) {
            $.ajax({
                // Passing the parameters over to the server for use there.
                // Everything before ? is the path to the route.
                // Everything after ? is the query string. So if the dates are both 2024-01-01 it's being passed as: /transactionDataForAnalytics?startDate=2024-01-01&endDate=2024-01-01
                // Then we can access startDate and endDate in the server.
                url: '/transactionDataForAnalytics?startDate=' + startDate + '&endDate=' + endDate,
                type: 'GET',
                dataType: 'json',
                success: function(response) {
                    // The arrays are in reverse order chronologically, so we're reversing them now.
                    var createdAt = response.createdAt.reverse();
                    var amounts = response.amounts.reverse();
                    var ids = response.ids.reverse();
                    var statuses = response.statuses.reverse();
                    var types = response.types.reverse();
                    var cardTypes = response.cardTypes.reverse();

                    console.log("Date array: ", createdAt);
                    console.log("Amount array: ", amounts);
                    console.log("ID array: ", ids);
                    console.log("Status array: ", statuses);
                    console.log("Type array: ", types);
                    console.log("Card type array: ", cardTypes);
                    

                    // These lines are creating arrays from the types and statuses arrays, but only with the unique values.
                    // A Set is an object that only allows unique values. So new Set(response.xxx) is creating Sets from those arrays and those sets inherently only contain the unique values in the array.
                    // The ... is the spread operator. It sort of "breaks down" an iterable that's passed into it's individual parts.
                    // So it's passed a set containing unique types/statuses and it pulls out those unique types/statuses.
                    // Then this is all wrapped in [] so it's creating an array from those types/statuses that ... pulled out of the Set.
                    var transactionTypes = [...new Set(types)];
                    var transactionStatuses = [...new Set(statuses)];
                    var transactionCardTypes = [...new Set(cardTypes)];

                    // Checking that the arrays are accurate.
                    console.log("Transaction types array: ", transactionTypes);
                    console.log("Transaction statuses array: ", transactionStatuses);

                    // Add checkboxes for each transaction type
                    transactionTypes.forEach(function(type) {
                        $('#transaction-types').append('<input type="checkbox" checked value="' + type + '">' + type + '<br>');
                    });

                    // Add checkboxes for each transaction status
                    transactionStatuses.forEach(function(status) {
                        $('#transaction-statuses').append('<input type="checkbox" checked value="' + status + '">' + status + '<br>');
                    });

                    // Add checkboxes for each transaction status
                    transactionCardTypes.forEach(function(status) {
                        $('#transaction-card-types').append('<input type="checkbox" checked value="' + status + '">' + status + '<br>');
                    });

                    // Function to draw the chart
                    function drawChart() {
                        // Check if the chart exists, then destroy it if it does.
                        if (transactionChart) {
                            transactionChart.destroy();
                        }

                        var selectedTypes = $('#transaction-types input:checked').map(function() {
                            return this.value;
                        }).get();

                        var selectedStatuses = $('#transaction-statuses input:checked').map(function() {
                            return this.value;
                        }).get();

                        var selectedCardTypes = $('#transaction-card-types input:checked').map(function() {
                            return this.value;
                        }).get();

                        // Now that we're just setting the x axis as the original, full createdAt array, the filteredIndex array is not necessary.
                        // Now instead, filteredDates gets added to in a similar manner as filteredAmounts.
                        // If the transaction in createdAt passes the filter, it gets added to array in the correct index.
                        // Otherwise, null is thrown in to keep the index accurate.
                        // This isn't actually being used anywhere rn, but maybe in the future?
                        var filteredDates = response.createdAt.map(function(date, i) {
                            if (selectedTypes.includes(response.types[i]) && selectedStatuses.includes(response.statuses[i]) && selectedCardTypes.includes(response.cardTypes[i])) {
                                return date;
                            }
                            else {
                                return null;
                            }
                        });

                        // Since we're keeping the x axis consistent now, changed how the transactions are filtered.
                        // Now, in order to keep this filteredAmounts array at the same length as the original array, we throw null values in the place of the original filtered out transaction.
                        // If the txn passes the filters, it gets added to the array. If it does not, null gets thrown in.
                        // This is important bc Chart.js will ignore a null value. So doing it like this means that only the transactions that pass the filter will show up in the graph.
                        var filteredAmounts = response.amounts.map(function(amount, i) {
                            if (selectedTypes.includes(response.types[i]) && selectedStatuses.includes(response.statuses[i]) && selectedCardTypes.includes(response.cardTypes[i])) {
                                return amount;
                            }
                            else {
                                return null;
                            }
                        });

                        console.log("filteredDates: ", filteredDates);
                        console.log("filteredAmounts: ", filteredAmounts);

                        var ctx = document.getElementById('transaction-chart');
                        transactionChart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: createdAt,
                                datasets: [{
                                    label: 'Transactions',
                                    data: filteredAmounts,
                                    backgroundColor: 'purple',
                                    borderColor: '#FF8E51',
                                    borderWidth: 1,
                                    spanGaps: true
                                }]
                            },
                            options: {
                                scales: {
                                    y: {
                                        beginAtZero: true
                                    }
                                },
                                // It's working! tooltip is nested inside of plugins. Now it shows a proper label.
                                plugins: {
                                    tooltip: {
                                        callbacks: {
                                            // Filtered index is not necessary anymore, so just grabbing the original index returned here.
                                            title: function(context) {
                                                var index = context[0].dataIndex;
                                                var transactionId = ids[index];
                                                return 'Transaction ID: ' + transactionId;
                                            },
                                            label: function(context) {
                                                var index = context.dataIndex;
                                                var amount = amounts[index];
                                                var status = statuses[index];
                                                var cardType = cardTypes[index];
                                                var type = types[index];
                                                var date = createdAt[index];

                                                return [
                                                    'Amount: $' + amount,
                                                    'Status: ' + status,
                                                    'Card Type: ' + cardType,
                                                    'Type: ' + type,
                                                    'Date: ' + date
                                                ];
                                            }
                                        }
                                    }
                                }
                            }
                        });

                        // Adding an onclick handler which triggers when a datapoint in the graph is clicked.
                        // It leads to the URL for that transaction in the BT Control Panel.
                        ctx.onclick = function(evt) {
                            // Once the user clicks somewhere on the chart, activePoints is filled with an array containing all of the datapoints in the graph.
                            var activePoints = transactionChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                            // If the user didn't click on a datapoint specifically, that activePoints array will be empty, hence less than 0 and so we don't do anything more.
                            if (activePoints.length > 0) {
                                console.log(activePoints);
                                // If they clicked on a datapoint, activePoints will be filled with data and so we do all of this.
                                // The 'nearest' parameter in getElementsAtEventForMode means that the function returns the datapoints nearest to where we clicked.
                                // If we had mulltipe datapoints at the same location, the activePoints array would fill with all of them.
                                // In this case, the graph only has one datapoint in any given location so activePoints always has a length of 1.

                                // So now we create a var containing the object with that 1 datapoint in activePoints.
                                var firstPoint = activePoints[0];
                                // That object contains an index which is it's position in the dataset that the graph was created from.
                                // So if it was the 4 datapoint, the index here will be 3.
                                // Updating this to use the filtered index we used above. Now, it'll pull the transaction from the index that was filterd with the checkboxes.
                                var index = firstPoint.index;
                                // Now we take that index and index the ids array we got back from the AJAX call.
                                // The correct transaction ID will be pulled here since the graph was created from that ids array.
                                var transactionId = ids[index];
                                // Merchant ID is now pulled from the .env file.
                                var merchantId = "{{merchantId}}";

                                // Constructing the URL and opening it in a new tab.
                                var url = 'https://sandbox.braintreegateway.com/merchants/' + merchantId + '/transactions/' + transactionId;
                                window.open(url, '_blank');
                            }
                        };
                    }

                    // Draw the chart initially
                    drawChart();

                    // Redraw the chart whenever a checkbox is checked or unchecked
                    $('#transaction-types input, #transaction-statuses input, #transaction-card-types input').change(drawChart);
                },
                error: function(jqXHR, status, error) {
                    console.log('AJAX call failed.');
                    console.log('Status: ' + status);
                    console.log('Error: ' + error);
                }
            });
        }

        // Event listener for the graph generator button. No graph is created until this is clicked.
        $('#graph-generator').click(function() {
            // Also doing this here so that the chart is destroyed immediately once the button is clicked.
            if (transactionChart) {
                transactionChart.destroy();
            }

            // Define the search parameters from the date inputs above.
            var startDate = $('#start-date').val();
            var endDate = $('#end-date').val();

            console.log(startDate);
            console.log(endDate);

            // If multiple searches were ran without reloading the page, the checkbox options would persist after each search.
            // Now clearing the checkbox divs when the search button is clicked.
            $('#transaction-types').empty();
            $('#transaction-statuses').empty();
            $('#transaction-card-types').empty();

            // Run the function to create the graph with these dates as the search parameters.
            generateGraph(startDate, endDate);
        });
    </script>
</body>